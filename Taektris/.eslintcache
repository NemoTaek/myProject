[{"/home/jht/codestates/개인프로젝트/myProject/Taektris/src/index.tsx":"1","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/reportWebVitals.ts":"2","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/App.tsx":"3","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/board.tsx":"4","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/constant.tsx":"5","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/piece.tsx":"6","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/map.tsx":"7"},{"size":500,"mtime":1609829406738,"results":"8","hashOfConfig":"9"},{"size":425,"mtime":1609829406738,"results":"10","hashOfConfig":"9"},{"size":14198,"mtime":1611649118780,"results":"11","hashOfConfig":"9"},{"size":6723,"mtime":1611649046486,"results":"12","hashOfConfig":"9"},{"size":1507,"mtime":1611124172869,"results":"13","hashOfConfig":"9"},{"size":2672,"mtime":1611294989572,"results":"14","hashOfConfig":"9"},{"size":3093,"mtime":1611643649462,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"kj58fi",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"18"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"/home/jht/codestates/개인프로젝트/myProject/Taektris/src/index.tsx",[],["34","35"],"/home/jht/codestates/개인프로젝트/myProject/Taektris/src/reportWebVitals.ts",[],"/home/jht/codestates/개인프로젝트/myProject/Taektris/src/App.tsx",["36"],"import React, { useEffect, useRef } from 'react';\nimport './App.css';\nimport { COLS, ROWS, BLOCK_SIZE, KEY, POINTS, LEVEL } from './component/constant'\nimport { map_standard, map_cliff, map_hi, map_egyptian } from './component/map'\nimport Board from './component/board'\n\nfunction App() {\n  let mapRef = useRef<HTMLCanvasElement>(null);\n  let nextRef = useRef<HTMLCanvasElement>(null);\n\n  // 판 선언\n  let board: Board;\n\n  // 맵 인덱스\n  let mapIndex: number = 0;\n\n  // 맵 배열\n  let mapGrid: number[][][] = [map_standard(), map_cliff(), map_hi(), map_egyptian()];\n\n  // 맵도 깊은 복사를 하여 기존의 맵에 영향을 주지 않도록 설계\n  // 블록 회전과 같은 원리\n  let selectMap: number[][][] = [];\n  for (let i = 0; i < mapGrid.length; i++) {\n    selectMap[i] = JSON.parse(JSON.stringify(mapGrid[i]));\n  }\n\n  // 게임 내 점수, 라인 수, 레벨 정보\n  let accountValues = {\n    score: 0,\n    lines: 0,\n    level: 0\n  }\n\n  useEffect(() => {\n    let map = mapRef.current;\n    let next = nextRef.current;\n    let mapContext = map.getContext('2d');\n    let nextContext = next.getContext('2d');\n\n    let requestId: any;\n    let time: any;\n\n    // 블럭 이동 세팅\n    const moves = {\n      [KEY.LEFT]: (p: any) => ({ ...p, x: p.x - 1 }),\n      [KEY.RIGHT]: (p: any) => ({ ...p, x: p.x + 1 }),\n      [KEY.DOWN]: (p: any) => ({ ...p, y: p.y + 1 }),\n      [KEY.SPACE]: (p: any) => ({ ...p, y: p.y + 1 }),\n      [KEY.UP]: (p: any) => board.rotate(p)\n    }\n\n    // bgm 및 기타 오디오 설정\n    let soundPlaying = false;\n    document.querySelector('#sound_speaker').textContent = \"\\u{1F507}\";\n    document.querySelector(\"#sound_description\").textContent = \"off\";\n    let bgmArray = [\n      \"asset/sounds/BRADINSKY.mp3\",\n      \"asset/sounds/KARINKA.mp3\",\n      \"asset/sounds/LOGINSKA.mp3\",\n      \"asset/sounds/TROIKA.mp3\",\n      \"asset/sounds/tetris_elec.mp3\"\n    ]\n\n    let opening: HTMLAudioElement = document.querySelector(\"#opening\");\n    let bgm: HTMLAudioElement = document.querySelector(\"#bgm\");\n    let gameoverSound: HTMLAudioElement = document.querySelector(\"#gameover\");\n    let dropSound: HTMLAudioElement = document.querySelector(\"#drop\");\n    let bgmElement: HTMLElement = document.querySelector(\"#sound_wrap\");\n    // bgm ON/OFF 클릭 시 소리 재생/중지\n    bgmElement.addEventListener(\"click\", () => {\n      if (!soundPlaying) {\n        opening.pause();\n        bgmOn();\n        soundPlaying = true;\n      }\n      else {\n        bgmOff();\n        soundPlaying = false;\n      }\n    });\n\n    // bgm 시작\n    const bgmOn = () => {\n      document.querySelector('#sound_speaker').textContent = \"\\u{1F509}\";\n      document.querySelector(\"#sound_description\").textContent = \"ON\";\n\n      // 위에서 선언한 src 배열중 랜덤으로 하나 선택 후 재생\n      bgm.src = bgmArray[Math.floor(Math.random() * bgmArray.length)];\n      bgm.load();\n      bgm.play();\n    }\n    // bgm 정지\n    const bgmOff = () => {\n      document.querySelector('#sound_speaker').textContent = \"\\u{1F507}\";\n      document.querySelector(\"#sound_description\").textContent = \"OFF\";\n      bgm.pause();\n    }\n\n    // bgm 랜덤재생\n    // bgm의 한 곡이 끝났을 때 다시 bgm을 시작하여 랜덤의 곡으로 재생\n    bgm.addEventListener(\"ended\", () => {\n      bgmOn();\n    })\n\n    // 레벨 커스텀\n    let levelUp: HTMLButtonElement = document.querySelector('.level_up');\n    levelUp.addEventListener(\"click\", () => {\n      levelDown.disabled = false;\n      // 최고 레벨은 10까지로 제한\n      if (accountValues.level >= 9) {\n        levelUp.disabled = true;\n      }\n      else {\n        levelUp.disabled = false;\n      }\n      accountValues.level++;\n      document.querySelector(\"#level\").textContent = accountValues.level.toString();\n    });\n\n    let levelDown: HTMLButtonElement = document.querySelector('.level_down');\n    // 처음 세팅은 level down을 할 수 없으므로 disabled\n    levelDown.disabled = true;\n    levelDown.addEventListener(\"click\", () => {\n      if (accountValues.level <= 1) {\n        levelDown.disabled = true;\n      }\n      // 10레벨에서 level down 버튼 클릭하면 다시 levelup 버튼 활성화\n      else if (accountValues.level >= 9) {\n        levelUp.disabled = false;\n      }\n      else {\n        levelDown.disabled = false;\n      }\n      accountValues.level--;\n      document.querySelector(\"#level\").textContent = accountValues.level.toString();\n    });\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // 맵 크기 설정\n    mapContext.canvas.width = COLS * BLOCK_SIZE;\n    mapContext.canvas.height = ROWS * BLOCK_SIZE;\n    mapContext.scale(BLOCK_SIZE, BLOCK_SIZE);\n    nextContext.canvas.width = 5 * BLOCK_SIZE;\n    nextContext.canvas.height = 4 * BLOCK_SIZE;\n    nextContext.scale(BLOCK_SIZE, BLOCK_SIZE);\n\n    // 맵 선택\n    let mapLeft: HTMLButtonElement = document.querySelector('.left');\n    let mapRight: HTMLButtonElement = document.querySelector('.right');\n\n    const rightOff = () => {\n      mapRight.disabled = true;\n      mapRight.style.borderLeftColor = \"grey\";\n      mapLeft.disabled = false;\n      mapLeft.style.borderRightColor = \"greenyellow\";\n    }\n    const leftOff = () => {\n      mapLeft.disabled = true;\n      mapLeft.style.borderRightColor = \"grey\";\n      mapRight.disabled = false;\n      mapRight.style.borderLeftColor = \"greenyellow\";\n    }\n    const bothOn = () => {\n      mapLeft.disabled = false;\n      mapLeft.style.borderRightColor = \"greenyellow\";\n      mapRight.disabled = false;\n      mapRight.style.borderLeftColor = \"greenyellow\";\n    }\n\n    // 첫 번째 맵이면 왼쪽 클릭 비활성화\n    if (mapIndex === 0) {\n      leftOff();\n    }\n\n    // 두 번째 맵 ~ 마지막에서 두번째 맵 이면 모두 활성화\n    else if (mapIndex > 0 && mapIndex < (mapGrid.length - 1)) {\n      bothOn();\n    }\n\n    // 마지막 맵이면 오른쪽 클릭 바활성화\n    if (mapIndex === (mapGrid.length - 1)) {\n      rightOff();\n    }\n\n    // 맵 변경 클릭 이벤트\n    mapLeft.addEventListener(\"click\", () => {\n      if (mapIndex > 0 && mapIndex < mapGrid.length) {\n        bothOn();\n        mapIndex--;\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        board = new Board(mapContext, nextContext, mapGrid[mapIndex]);\n        board.drawBoard();\n\n        // 클릭 하고 첫번째 맵이 되면 왼쪽 클릭 비활성화\n        if (mapIndex === 0) {\n          leftOff();\n        }\n      }\n    });\n\n    mapRight.addEventListener(\"click\", () => {\n      if (0 <= mapIndex && mapIndex < (mapGrid.length - 1)) {\n        bothOn();\n        mapIndex++;\n        mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n        board = new Board(mapContext, nextContext, mapGrid[mapIndex]);\n        board.drawBoard();\n\n        // 클릭 하고 마지막 맵이 되면 오른쪽 클릭 비활성화\n        if (mapIndex === (mapGrid.length - 1)) {\n          rightOff();\n        }\n      }\n    });\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // 게임 시작 버튼 클릭 후 로직\n\n    // 게임 시작 버튼 클릭\n    document.querySelector('.play-button').addEventListener(\"click\", (e) => {\n      // 시작 시마다 맵 초기화\n      for (let i = 0; i < mapGrid.length; i++) {\n        selectMap[i] = JSON.parse(JSON.stringify(mapGrid[i]));\n      }\n\n      // 선택한 맵 그리기\n      mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n      board = new Board(mapContext, nextContext, selectMap[mapIndex]);\n\n      // 오프닝 bgm 중지\n      opening.pause();\n\n      // 점수, 라인 수 초기화\n      accountValues.score = 0;\n      accountValues.lines = 0;\n\n      // 레벨 커스텀 중지\n      levelUp.style.display = \"none\";\n      levelDown.style.display = \"none\";\n\n      // 맵 선택 중지\n      mapLeft.style.display = \"none\";\n      mapRight.style.display = \"none\";\n\n      // 게임 시작\n      play();\n\n      // bgm 온\n      soundPlaying = true;\n      bgmOn();\n    }, true);\n\n    // 게임 시작\n    const play = (): void => {\n      addEventListener();\n      if (requestId) {\n        cancelAnimationFrame(requestId);\n      }\n      resetGame();\n      animate();\n    }\n\n    // 게임 설정 초기화\n    const resetGame = (): void => {\n      document.querySelector(\"#level\").textContent = accountValues.level.toString();\n      board.reset();\n      // 시작 시간, 경과 시간, 해당 레벨의 낙하 속도를 가지는 타이머 객체\n      time = { start: performance.now(), elapsed: 0, level: LEVEL[accountValues.level] };\n    }\n\n    const animate = (now: number = 0): void => {\n      // 점수, 라인 수, 레벨 출력\n      document.querySelector(\"#score\").textContent = accountValues.score.toString();\n      document.querySelector(\"#lines\").textContent = accountValues.lines.toString();\n      document.querySelector(\"#level\").textContent = accountValues.level.toString();\n\n      // 경과시간 업데이트\n      time.elapsed = now - time.start;\n\n      // 경과시간이 현재 레벨의 시간을 넘었다면\n      // 시작시간을 0으로 초기화 하고 하강시킴\n      if (time.elapsed > time.level) {\n        time.start = now;\n\n        // 시작시간을 초기화 하자마자 충돌이 나면 게임오버\n        if (!board.drop(moves, time, accountValues)) {\n          gameOver();\n          return;\n        }\n      }\n\n      // 맵 초기화 후 그리기\n      mapContext.clearRect(0, 0, mapContext.canvas.width, mapContext.canvas.height);\n      board.drawPiece();\n\n      // 애니메이션 변수에 담아 flag 설정\n      requestId = requestAnimationFrame(animate);\n    }\n\n    // 키보드 이벤트(블록 움직임, 하드 드롭, 일시정지)\n    const addEventListener = () => {\n      document.removeEventListener('keydown', handleKeyPress);\n      document.addEventListener('keydown', handleKeyPress);\n    }\n\n    const handleKeyPress = (event: any) => {\n      if (moves[event.code]) {\n        // 이벤트 버블링 방지\n        event.preventDefault();\n\n        // 조각의 상태를 얻음\n        let p = moves[event.code](board.piece);\n\n        // space 누르면 수직 강하\n        if (event.code === KEY.SPACE) {\n          while (board.valid(p)) {\n            board.piece.move(p);\n            p = moves[KEY.DOWN](board.piece);\n            accountValues.score += POINTS.HARD_DROP;\n          }\n          board.piece.hardDrop();\n          dropSound.src = \"asset/sounds/drop.mp3\";\n          dropSound.load();\n          dropSound.play();\n        }\n\n        // 이동이 가능한 상태라면 이동\n        else if (board.valid(p)) {\n          board.piece.move(p);\n          if (event.code === KEY.DOWN) {\n            accountValues.score += POINTS.SOFT_DROP;\n          }\n        }\n      }\n\n      // p 키를 눌러 일시정지\n      else if (event.code === KEY.P) {\n        pause();\n      }\n    };\n\n    // 게임오버\n    const gameOver = () => {\n      bgmOff();\n      cancelAnimationFrame(requestId);\n\n      // game over 창 띄우기\n      mapContext.fillStyle = 'white';\n      mapContext.fillRect(1, 3, 8, 1.2);\n      mapContext.font = '1px Arial';\n      mapContext.fillStyle = 'red';\n      mapContext.fillText('GAME OVER', 1.8, 4);\n\n      gameoverSound.src = \"asset/sounds/gameover.mp3\";\n      gameoverSound.load();\n      gameoverSound.play();\n\n      // 레벨 커스텀 활성화\n      levelUp.style.display = \"inline-block\";\n      levelDown.style.display = \"inline-block\";\n\n      // 맵 선택 활성화\n      mapLeft.style.display = \"inline-block\";\n      mapRight.style.display = \"inline-block\";\n    }\n\n    // 일시정지\n    const pause = () => {\n      // 일시정지 중이었다면 다시 실행\n      if (!requestId) {\n        animate();\n        bgmOn();\n        return;\n      }\n\n      // 진행중이었다면 일시정지\n      cancelAnimationFrame(requestId);\n      requestId = null;\n\n      mapContext.fillStyle = 'white';\n      mapContext.fillRect(1, 3, 8, 1.2);\n      mapContext.font = '1px Arial';\n      mapContext.fillStyle = 'red';\n      mapContext.fillText('PAUSED', 3, 4);\n\n      bgmOff();\n    }\n  })\n\n  return (\n    <div id=\"background\">\n      <div className=\"wrap\">\n        <div className=\"tetris_map_wrap\">\n          <div className=\"arrow_wrap\">\n            <button className=\"triangle left\"></button>\n          </div>\n          <canvas id=\"tetris_map\" ref={mapRef}></canvas>\n          <div className=\"arrow_wrap\">\n            <button className=\"triangle right\"></button>\n          </div>\n        </div>\n        <div className=\"next_wrap\">\n          <div className=\"next_wrap_info\">\n            <h1>TETRIS</h1>\n            <p>Score: <span id=\"score\">0</span></p>\n            <p>Lines: <span id=\"lines\">0</span></p>\n            <div>\n              <p style={{ display: \"inline-block\" }}>Level: <span id=\"level\">{accountValues.level}</span></p>\n              <div className=\"level_wrap\">\n                <button className=\"level_up\">↑</button>\n                <button className=\"level_down\">↓</button>\n              </div>\n            </div>\n            <div className=\"next\">\n              <p>NEXT</p>\n              <canvas id=\"next\" ref={nextRef} style={{ backgroundColor: \"black\" }}></canvas>\n            </div>\n            <div id=\"sound_wrap\">\n              <span className=\"sound_item\" id=\"sound_speaker\"></span>\n              <span className=\"sound_item\" id=\"sound_description\"></span>\n              {/* <iframe title=\"a\" id=\"openingIframe\" src=\"asset/sounds/drop.mp3\" allow=\"autoplay\" style={{ display: \"none\" }}></iframe> */}\n              <audio id=\"opening\" autoPlay>\n                <source src=\"asset/sounds/opening.mp3\" type=\"audio/mp3\"></source>\n              </audio>\n              <audio id=\"bgm\"></audio>\n              <audio id=\"line\"></audio>\n              <audio id=\"drop\"></audio>\n              <audio id=\"gameover\"></audio>\n            </div>\n          </div>\n          <button className=\"play-button\">Play</button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/board.tsx",["37"],"import { COLS, ROWS, BLOCK_SIZE, LINES_PER_LEVEL, COLORS, KEY, POINTS, LEVEL } from './constant'\nimport Piece from './piece'\n\ninterface board {\n  ctx: any; // CanvasRenderingContext2D { ... }\n  grid: any;  // 맵의 격자\n  piece: Piece; // 맵에 나오는 블럭\n  nextPiece: Piece; // 다음에 나올 블럭\n\n  reset(): void;  // 새 게임이 시작되면 맵 초기화\n  getNextPiece(): void;  // NEXT 블럭 정하는 함수\n  drawPiece(): void;  // 블럭 그리는 함수\n  drawBoard(): void;  // 맵에 블럭 그리는 함수\n  valid(p: any): boolean; // 충돌 검사 함수\n  isInsideWalls(x: number, y: number): boolean; // 맵 내의 충돌 감지하는 함수\n  isDropped(x: number, y: number): boolean; // 놓여질 곳에 블럭이 있는지 검사하는 함수\n  rotate(p: any): Array<Array<number>>;  // 블럭 회전 함수\n  drop(move: any, time: any, account: any): boolean;  // 블럭을 내리는 함수\n  freeze(): void; // 더이상 내려갈 수 없는 곳에 닿았을 때 블럭 놓는 함수\n  clearLines(time: any, account: any): void; // 한 줄이 다 채워질 경우 라인 삭제 함수\n  getLinesClearedPoints(lines: number); // 라인 별 점수\n}\n\nclass Board implements board {\n  // grid: any;\n  piece: Piece;\n  nextPiece: Piece;\n\n  constructor(public ctx: any, public nextCtx: any, public grid: any) {\n    this.ctx = ctx;\n    this.nextCtx = nextCtx;\n    this.grid = grid;\n  }\n\n  // 새 게임이 시작되면 맵 초기화\n  reset() {\n    this.piece = new Piece(this.ctx);\n    this.piece.setStartingPosition();\n    this.getNextPiece();\n  }\n\n  // // 0으로 채워진 행렬\n  // getEmptyGrid() {\n  //   return Array.from(\n  //     { length: ROWS }, () => Array(COLS).fill(0)\n  //   );\n  //   // return map1();\n  // }\n\n  // NEXT 블럭 정하는 함수\n  getNextPiece() {\n    this.nextPiece = new Piece(this.nextCtx);\n    this.nextCtx.clearRect(0, 0, this.nextCtx.canvas.width, this.nextCtx.canvas.height);\n    this.nextPiece.setNextPosition();\n    this.nextPiece.draw();\n  }\n\n  // 블럭 그리는 함수\n  drawPiece() {\n    this.piece.draw();\n    this.drawBoard();\n  }\n\n  // 맵에 블럭 그리는 함수\n  drawBoard() {\n    this.grid.forEach((row: Array<number>, y: number) => {\n      row.forEach((value: number, x: number) => {\n        if (value > 0) {\n          this.ctx.strokeStyle = \"#964b00\";\n          this.ctx.lineWidth = 0.025;\n          this.ctx.strokeRect(x, y, 1, 1);\n          this.ctx.fillStyle = COLORS[value];\n          this.ctx.fillRect(x, y, 1, 1);\n        }\n      });\n    });\n  }\n\n  // 충돌 검사 함수\n  valid(p: any) {\n    return p.shape.every((row: Array<number>, dy: number) => {\n      return row.every((value: number, dx: number) => {\n        let x = p.x + dx;\n        let y = p.y + dy;\n        return value === 0 || (this.isInsideWalls(x, y) && this.isDropped(x, y));\n      });\n    });\n  }\n\n  // 맵 내의 충돌 감지하는 함수\n  isInsideWalls(x: number, y: number) {\n    return x >= 0 && x < COLS && y <= ROWS;\n  }\n\n  // 놓여질 곳에 블럭이 있는지 검사하는 함수\n  isDropped(x: number, y: number) {\n    return this.grid[y] && this.grid[y][x] === 0;\n  }\n\n\n  // 블럭 회전 함수\n  rotate(piece: any) {\n    // JSON.stringify(arg): arg를 JSON 문자열로 변환\n    // JSON.parse(json): json 문자열을 javascript에서 사용하는 값으로 변환\n    // 변환하지 않고 사용하면 shape 배열이 이전 값을 기억하고 다음 나올 블럭이 변환된 상태로 나오게 됨\n    // 불변성을 이용하여 현재 블럭이 다음 나올 블럭에 영향을 주지 않도록 깊은 복사하여 사용\n    let p = JSON.parse(JSON.stringify(piece));\n\n    // 행렬을 사용하여 시계방향으로 90도 회전 방법: \n    // 전치행렬로 기존 행렬의 행과 열을 바꾸고,\n    // [0,0,1]\n    // [0,1,0] 을 곱하여 열 기준 대칭\n    // [1,0,0]\n    if (!this.piece.hardDropped) {\n      for (let y = 0; y < p.shape.length; ++y) {\n        for (let x = 0; x < y; ++x) {\n          [p.shape[x][y], p.shape[y][x]] = [p.shape[y][x], p.shape[x][y]];\n        }\n      }\n      // 열 기준 대칭\n      p.shape.forEach((row: Array<number>) => row.reverse());\n    }\n\n    return p;\n  }\n\n  // 블럭을 내리는 함수\n  drop(moves: any, time: any, account: any) {\n    // 내려갈 곳이 있으면 1칸씩 하강\n    let p = moves[KEY.DOWN](this.piece);\n    if (this.valid(p)) {\n      this.piece.move(p);\n    }\n\n    // 없으면 멈추고, 라인을 삭제\n    // next에 있는 블럭을 맵에 그리기\n    else {\n      this.freeze();\n      this.clearLines(time, account);\n\n      // 블럭을 놓을 자리가 없으면 게임오버\n      if (this.piece.y === 0) {\n        return false;\n      }\n\n      this.piece = this.nextPiece;\n      this.piece.ctx = this.ctx;\n      this.piece.setStartingPosition();\n      this.getNextPiece();\n    }\n    return true;\n  }\n\n  // 더이상 내려갈 수 없는 곳에 닿았을 때 블럭 놓는 함수\n  // grid 격자에 블록이 추가가 된 것이므로 블록에 해당하는 id 값을 grid에 추가\n  freeze() {\n    this.piece.shape.forEach((row: Array<number>, y: number) => {\n      row.forEach((value: number, x: number) => {\n        if (value > 0) {\n          this.grid[y + this.piece.y][x + this.piece.x] = value;\n        }\n      });\n    });\n  }\n\n  // 한 줄이 다 채워질 경우 라인 삭제 함수\n  clearLines(time: any, account: any) {\n    let lines = 0;\n    this.grid.forEach((row: Array<number>, y: number) => {\n\n      // gird에서 하나의 행이 모두 0 이상의 값으로 채워지면 라인 삭제\n      if (row.every((value: number) => value > 0)) {\n        lines++;\n\n        // 행 삭제\n        this.grid.splice(y, 1);\n\n        // 삭제한 라인을 상단에 0으로 추가\n        this.grid.unshift(Array(COLS).fill(0));\n      }\n    });\n\n    if (lines > 0) {\n      // 지워진 라인 수만큼 점수 추가\n      account.score += this.getLinesClearedPoints(lines);\n      account.lines += lines;\n\n      let lineSound = new Audio(\"asset/sounds/line.mp3\");\n      lineSound.load();\n      lineSound.play();\n\n      // 일정 기준치의 라인을 제거하면 레벨 상승\n      if (account.lines >= LINES_PER_LEVEL) {\n        account.level++;\n\n        // 다음 레벨을 위하여 기존의 라인을 삭제\n        account.lines -= LINES_PER_LEVEL;\n\n        // 레벨이 오르면 속도도 상승\n        time.level = LEVEL[account.level];\n      }\n    }\n  }\n\n  // 라인 별 점수\n  getLinesClearedPoints(lines: number) {\n    return lines === 1 ? POINTS.SINGLE :\n      lines === 2 ? POINTS.DOUBLE :\n        lines === 3 ? POINTS.TRIPLE :\n          lines === 4 ? POINTS.TETRIS :\n            0;\n  }\n}\n\nexport default Board;","/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/constant.tsx",[],"/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/piece.tsx",[],["38","39"],"/home/jht/codestates/개인프로젝트/myProject/Taektris/src/component/map.tsx",[],{"ruleId":"40","replacedBy":"41"},{"ruleId":"42","replacedBy":"43"},{"ruleId":"44","severity":1,"message":"45","line":192,"column":17,"nodeType":"46","endLine":192,"endColumn":70},{"ruleId":"47","severity":1,"message":"48","line":1,"column":22,"nodeType":"49","messageId":"50","endLine":1,"endColumn":32},{"ruleId":"40","replacedBy":"51"},{"ruleId":"42","replacedBy":"52"},"no-native-reassign",["53"],"no-negated-in-lhs",["54"],"react-hooks/exhaustive-deps","Assignments to the 'board' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","NewExpression","@typescript-eslint/no-unused-vars","'BLOCK_SIZE' is defined but never used.","Identifier","unusedVar",["53"],["54"],"no-global-assign","no-unsafe-negation"]